<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How to Build and Run the Compiler - Guide to Rustc Development</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="about-this-guide.html">About this guide</a></li><li class="spacer"></li><li><a href="part-1-intro.html"><strong aria-hidden="true">1.</strong> Part 1: Building, debugging, and contributing to Rustc</a></li><li><ol class="section"><li><a href="compiler-team.html"><strong aria-hidden="true">1.1.</strong> About the compiler team</a></li><li><a href="how-to-build-and-run.html" class="active"><strong aria-hidden="true">1.2.</strong> How to Build and Run the Compiler</a></li><li><ol class="section"><li><a href="build-install-distribution-artifacts.html"><strong aria-hidden="true">1.2.1.</strong> Build and Install distribution artifacts</a></li><li><a href="compiler-documenting.html"><strong aria-hidden="true">1.2.2.</strong> Documenting Compiler</a></li></ol></li><li><a href="tests/intro.html"><strong aria-hidden="true">1.3.</strong> The compiler testing framework</a></li><li><ol class="section"><li><a href="tests/running.html"><strong aria-hidden="true">1.3.1.</strong> Running tests</a></li><li><a href="tests/adding.html"><strong aria-hidden="true">1.3.2.</strong> Adding new tests</a></li><li><a href="compiletest.html"><strong aria-hidden="true">1.3.3.</strong> Using compiletest + commands to control test execution</a></li></ol></li><li><a href="walkthrough.html"><strong aria-hidden="true">1.4.</strong> Walkthrough: a typical contribution</a></li><li><a href="implementing_new_features.html"><strong aria-hidden="true">1.5.</strong> Implementing new features</a></li><li><a href="stability.html"><strong aria-hidden="true">1.6.</strong> Stability attributes</a></li><li><a href="stabilization_guide.html"><strong aria-hidden="true">1.7.</strong> Stabilizing Features</a></li><li><a href="compiler-debugging.html"><strong aria-hidden="true">1.8.</strong> Debugging the Compiler</a></li><li><a href="profiling.html"><strong aria-hidden="true">1.9.</strong> Profiling the compiler</a></li><li><ol class="section"><li><a href="profiling/with_perf.html"><strong aria-hidden="true">1.9.1.</strong> with the linux perf tool</a></li></ol></li><li><a href="conventions.html"><strong aria-hidden="true">1.10.</strong> Coding conventions</a></li><li><a href="crates-io.html"><strong aria-hidden="true">1.11.</strong> crates.io Dependencies</a></li><li><a href="diagnostics.html"><strong aria-hidden="true">1.12.</strong> Emitting Errors and other Diagnostics</a></li><li><a href="ice-breaker/about.html"><strong aria-hidden="true">1.13.</strong> ICE-breaker teams</a></li><li><ol class="section"><li><a href="ice-breaker/llvm.html"><strong aria-hidden="true">1.13.1.</strong> LLVM ICE-breakers</a></li></ol></li></ol></li><li><a href="part-2-intro.html"><strong aria-hidden="true">2.</strong> Part 2: How rustc works</a></li><li><ol class="section"><li><a href="high-level-overview.html"><strong aria-hidden="true">2.1.</strong> High-level overview of the compiler source</a></li><li><a href="rustc-driver.html"><strong aria-hidden="true">2.2.</strong> The Rustc Driver and Interface</a></li><li><ol class="section"><li><a href="rustdoc.html"><strong aria-hidden="true">2.2.1.</strong> Rustdoc</a></li></ol></li><li><a href="query.html"><strong aria-hidden="true">2.3.</strong> Queries: demand-driven compilation</a></li><li><ol class="section"><li><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">2.3.1.</strong> The Query Evaluation Model in Detail</a></li><li><a href="queries/incremental-compilation.html"><strong aria-hidden="true">2.3.2.</strong> Incremental compilation</a></li><li><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">2.3.3.</strong> Incremental compilation In Detail</a></li><li><a href="incrcomp-debugging.html"><strong aria-hidden="true">2.3.4.</strong> Debugging and Testing</a></li></ol></li><li><a href="the-parser.html"><strong aria-hidden="true">2.4.</strong> The parser</a></li><li><a href="test-implementation.html"><strong aria-hidden="true">2.5.</strong> #[test] Implementation</a></li><li><a href="macro-expansion.html"><strong aria-hidden="true">2.6.</strong> Macro expansion</a></li><li><a href="name-resolution.html"><strong aria-hidden="true">2.7.</strong> Name resolution</a></li><li><a href="hir.html"><strong aria-hidden="true">2.8.</strong> The HIR (High-level IR)</a></li><li><ol class="section"><li><a href="lowering.html"><strong aria-hidden="true">2.8.1.</strong> Lowering AST to HIR</a></li><li><a href="hir-debugging.html"><strong aria-hidden="true">2.8.2.</strong> Debugging</a></li></ol></li><li><a href="closure.html"><strong aria-hidden="true">2.9.</strong> Closure expansion</a></li><li><a href="ty.html"><strong aria-hidden="true">2.10.</strong> The ty module: representing types</a></li><li><a href="generic_arguments.html"><strong aria-hidden="true">2.11.</strong> Generic arguments</a></li><li><a href="type-inference.html"><strong aria-hidden="true">2.12.</strong> Type inference</a></li><li><a href="traits/resolution.html"><strong aria-hidden="true">2.13.</strong> Trait solving (old-style)</a></li><li><ol class="section"><li><a href="traits/hrtb.html"><strong aria-hidden="true">2.13.1.</strong> Higher-ranked trait bounds</a></li><li><a href="traits/caching.html"><strong aria-hidden="true">2.13.2.</strong> Caching subtleties</a></li><li><a href="traits/specialization.html"><strong aria-hidden="true">2.13.3.</strong> Specialization</a></li></ol></li><li><a href="traits/index.html"><strong aria-hidden="true">2.14.</strong> Trait solving (new-style)</a></li><li><ol class="section"><li><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">2.14.1.</strong> Lowering to logic</a></li><li><ol class="section"><li><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">2.14.1.1.</strong> Goals and clauses</a></li><li><a href="traits/associated-types.html"><strong aria-hidden="true">2.14.1.2.</strong> Equality and associated types</a></li><li><a href="traits/implied-bounds.html"><strong aria-hidden="true">2.14.1.3.</strong> Implied bounds</a></li><li><a href="traits/regions.html"><strong aria-hidden="true">2.14.1.4.</strong> Region constraints</a></li><li><a href="traits/lowering-module.html"><strong aria-hidden="true">2.14.1.5.</strong> The lowering module in rustc</a></li><li><a href="traits/lowering-rules.html"><strong aria-hidden="true">2.14.1.6.</strong> Lowering rules</a></li><li><a href="traits/wf.html"><strong aria-hidden="true">2.14.1.7.</strong> Well-formedness checking</a></li></ol></li><li><a href="traits/canonical-queries.html"><strong aria-hidden="true">2.14.2.</strong> Canonical queries</a></li><li><ol class="section"><li><a href="traits/canonicalization.html"><strong aria-hidden="true">2.14.2.1.</strong> Canonicalization</a></li></ol></li><li><a href="traits/slg.html"><strong aria-hidden="true">2.14.3.</strong> The SLG solver</a></li><li><a href="traits/chalk-overview.html"><strong aria-hidden="true">2.14.4.</strong> An Overview of Chalk</a></li><li><a href="traits/bibliography.html"><strong aria-hidden="true">2.14.5.</strong> Bibliography</a></li></ol></li><li><a href="type-checking.html"><strong aria-hidden="true">2.15.</strong> Type checking</a></li><li><ol class="section"><li><a href="method-lookup.html"><strong aria-hidden="true">2.15.1.</strong> Method Lookup</a></li><li><a href="variance.html"><strong aria-hidden="true">2.15.2.</strong> Variance</a></li><li><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">2.15.3.</strong> Opaque Types</a></li></ol></li><li><a href="mir/index.html"><strong aria-hidden="true">2.16.</strong> The MIR (Mid-level IR)</a></li><li><ol class="section"><li><a href="mir/construction.html"><strong aria-hidden="true">2.16.1.</strong> MIR construction</a></li><li><a href="mir/visitor.html"><strong aria-hidden="true">2.16.2.</strong> MIR visitor and traversal</a></li><li><a href="mir/passes.html"><strong aria-hidden="true">2.16.3.</strong> MIR passes: getting the MIR for a function</a></li><li><a href="mir/optimizations.html"><strong aria-hidden="true">2.16.4.</strong> MIR optimizations</a></li><li><a href="mir/debugging.html"><strong aria-hidden="true">2.16.5.</strong> Debugging</a></li></ol></li><li><a href="borrow_check.html"><strong aria-hidden="true">2.17.</strong> The borrow checker</a></li><li><ol class="section"><li><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">2.17.1.</strong> Tracking moves and initialization</a></li><li><ol class="section"><li><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">2.17.1.1.</strong> Move paths</a></li></ol></li><li><a href="borrow_check/type_check.html"><strong aria-hidden="true">2.17.2.</strong> MIR type checker</a></li><li><a href="borrow_check/region_inference.html"><strong aria-hidden="true">2.17.3.</strong> Region inference</a></li><li><ol class="section"><li><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">2.17.3.1.</strong> Constraint propagation</a></li><li><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">2.17.3.2.</strong> Lifetime parameters</a></li><li><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">2.17.3.3.</strong> Member constraints</a></li><li><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">2.17.3.4.</strong> Placeholders and universes</a></li><li><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">2.17.3.5.</strong> Closure constraints</a></li><li><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">2.17.3.6.</strong> Error reporting</a></li></ol></li><li><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">2.17.4.</strong> Two-phase-borrows</a></li></ol></li><li><a href="const-eval.html"><strong aria-hidden="true">2.18.</strong> Constant evaluation</a></li><li><ol class="section"><li><a href="miri.html"><strong aria-hidden="true">2.18.1.</strong> miri const evaluator</a></li></ol></li><li><a href="param_env.html"><strong aria-hidden="true">2.19.</strong> Parameter Environments</a></li><li><a href="codegen.html"><strong aria-hidden="true">2.20.</strong> Code Generation</a></li><li><ol class="section"><li><a href="codegen/updating-llvm.html"><strong aria-hidden="true">2.20.1.</strong> Updating LLVM</a></li><li><a href="codegen/debugging.html"><strong aria-hidden="true">2.20.2.</strong> Debugging LLVM</a></li></ol></li><li><a href="profile-guided-optimization.html"><strong aria-hidden="true">2.21.</strong> Profile-guided Optimization</a></li><li><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">2.22.</strong> Debugging Support in Rust Compiler</a></li><li class="spacer"></li></ol></li><li><a href="appendix/stupid-stats.html">Appendix A: Stupid Stats</a></li><li class="affix"><a href="appendix/background.html">Appendix B: Background material</a></li><li class="affix"><a href="appendix/glossary.html">Appendix C: Glossary</a></li><li class="affix"><a href="appendix/code-index.html">Appendix D: Code Index</a></li><li class="affix"><a href="appendix/bibliography.html">Appendix E: Bibliography</a></li><li class="affix"><a href="appendix/humorust.html">Appendix Z: HumorRust</a></li><li class="spacer"></li><li class="affix"><a href="important-links.html"></a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Guide to Rustc Development</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#how-to-build-and-run-the-compiler" id="how-to-build-and-run-the-compiler">How to Build and Run the Compiler</a></h1>
<p>The compiler is built using a tool called <code>x.py</code>. You will need to
have Python installed to run it. But before we get to that, if you're going to
be hacking on <code>rustc</code>, you'll want to tweak the configuration of the compiler.
The default configuration is oriented towards running the compiler as a user,
not a developer.</p>
<h3><a class="header" href="#create-a-configtoml" id="create-a-configtoml">Create a config.toml</a></h3>
<p>To start, copy <a href="https://github.com/rust-lang/rust/blob/master/config.toml.example"><code>config.toml.example</code></a> to <code>config.toml</code>:</p>
<pre><code class="language-bash">&gt; cd $RUST_CHECKOUT
&gt; cp config.toml.example config.toml
</code></pre>
<p>Then you will want to open up the file and change the following
settings (and possibly others, such as <code>llvm.ccache</code>):</p>
<pre><code class="language-toml">[llvm]
# Enables LLVM assertions, which will check that the LLVM bitcode generated
# by the compiler is internally consistent. These are particularly helpful
# if you edit `codegen`.
assertions = true

[rust]
# This will make your build more parallel; it costs a bit of runtime
# performance perhaps (less inlining) but it's worth it.
codegen-units = 0

# This enables full debuginfo and debug assertions. The line debuginfo is also
# enabled by `debuginfo-level = 1`. Full debuginfo is also enabled by
# `debuginfo-level = 2`. Debug assertions can also be enabled with
# `debug-assertions = true`. Note that `debug = true` will make your build
# slower, so you may want to try individually enabling debuginfo and assertions
# or enable only line debuginfo which is basically free.
debug = true
</code></pre>
<p>If you have already built <code>rustc</code>, then you may have to execute <code>rm -rf build</code> for subsequent
configuration changes to take effect. Note that <code>./x.py clean</code> will not cause a
rebuild of LLVM, so if your configuration change affects LLVM, you will need to
manually <code>rm -rf build/</code> before rebuilding.</p>
<h3><a class="header" href="#what-is-xpy" id="what-is-xpy">What is <code>x.py</code>?</a></h3>
<p><code>x.py</code> is the script used to orchestrate the tooling in the <code>rustc</code> repository.
It is the script that can build docs, run tests, and compile <code>rustc</code>.
It is the now preferred way to build <code>rustc</code> and it replaces the old makefiles
from before. Below are the different ways to utilize <code>x.py</code> in order to
effectively deal with the repo for various common tasks.</p>
<h3><a class="header" href="#running-xpy-and-building-a-stage1-compiler" id="running-xpy-and-building-a-stage1-compiler">Running <code>x.py</code> and building a stage1 compiler</a></h3>
<p>One thing to keep in mind is that <code>rustc</code> is a <em>bootstrapping</em>
compiler. That is, since <code>rustc</code> is written in Rust, we need to use an
older version of the compiler to compile the newer version. In
particular, the newer version of the compiler and some of the artifacts needed
to build it, such as <code>libstd</code> and other tooling, may use some unstable features
internally, requiring a specific version which understands these unstable
features.</p>
<p>The result is that compiling <code>rustc</code> is done in stages:</p>
<ul>
<li><strong>Stage 0:</strong> the stage0 compiler is usually (you can configure <code>x.py</code> to use
something else) the current <em>beta</em> <code>rustc</code> compiler and its associated dynamic
libraries (which <code>x.py</code> will download for you). This stage0 compiler is then
used only to compile <code>rustbuild</code>, <code>std</code>, and <code>rustc</code>. When compiling
<code>rustc</code>, this stage0 compiler uses the freshly compiled <code>std</code>.
There are two concepts at play here: a compiler (with its set of dependencies)
and its 'target' or 'object' libraries (<code>std</code> and <code>rustc</code>).
Both are staged, but in a staggered manner.</li>
<li><strong>Stage 1:</strong> the code in your clone (for new version) is then
compiled with the stage0 compiler to produce the stage1 compiler.
However, it was built with an older compiler (stage0), so to
optimize the stage1 compiler we go to next the stage.
<ul>
<li>In theory, the stage1 compiler is functionally identical to the
stage2 compiler, but in practice there are subtle differences. In
particular, the stage1 compiler itself was built by stage0 and
hence not by the source in your working directory: this means that
the symbol names used in the compiler source may not match the
symbol names that would have been made by the stage1 compiler.
This can be important when using dynamic linking (e.g., with
derives. Sometimes this means that some tests don't work when run
with stage1.</li>
</ul>
</li>
<li><strong>Stage 2:</strong> we rebuild our stage1 compiler with itself to produce
the stage2 compiler (i.e. it builds itself) to have all the <em>latest
optimizations</em>. (By default, we copy the stage1 libraries for use by
the stage2 compiler, since they ought to be identical.)</li>
<li><em>(Optional)</em> <strong>Stage 3</strong>: to sanity check our new compiler, we
can build the libraries with the stage2 compiler. The result ought
to be identical to before, unless something has broken.</li>
</ul>
<h4><a class="header" href="#a-note-on-stage-meanings" id="a-note-on-stage-meanings">A note on stage meanings</a></h4>
<p>When running <code>x.py</code> you will see output such as:</p>
<pre><code class="language-txt">Building stage0 std artifacts
Copying stage0 std from stage0
Building stage0 compiler artifacts
Copying stage0 rustc from stage0
Building LLVM for x86_64-apple-darwin
Building stage0 codegen artifacts
Assembling stage1 compiler
Building stage1 std artifacts
Copying stage1 std from stage1
Building stage1 compiler artifacts
Copying stage1 rustc from stage1
Building stage1 codegen artifacts
Assembling stage2 compiler
Uplifting stage1 std
Copying stage2 std from stage1
Generating unstable book md files
Building stage0 tool unstable-book-gen
Building stage0 tool rustbook
Documenting standalone
Building rustdoc for stage2
Documenting book redirect pages
Documenting stage2 std
Building rustdoc for stage1
Documenting stage2 whitelisted compiler
Documenting stage2 compiler
Documenting stage2 rustdoc
Documenting error index
Uplifting stage1 rustc
Copying stage2 rustc from stage1
Building stage2 tool error_index_generator
</code></pre>
<p>A deeper look into <code>x.py</code>'s phases can be seen here:</p>
<img alt="A diagram of the rustc compilation phases" src="img/rustc_stages.svg" class="center" />
<p>Keep in mind this diagram is a simplification, i.e. <code>rustdoc</code> can be built at
different stages, the process is a bit different when passing flags such as
<code>--keep-stage</code>, or if there are non-host targets.</p>
<p>The following tables indicate the outputs of various stage actions:</p>
<table><thead><tr><th>Stage 0 Action</th><th>Output</th></tr></thead><tbody>
<tr><td><code>beta</code> extracted</td><td><code>build/HOST/stage0</code></td></tr>
<tr><td><code>stage0</code> builds <code>bootstrap</code></td><td><code>build/bootstrap</code></td></tr>
<tr><td><code>stage0</code> builds <code>libstd</code></td><td><code>build/HOST/stage0-std/TARGET</code></td></tr>
<tr><td>copy <code>stage0-std</code> (HOST only)</td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage0-rustc (except executable)</code></td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td>build <code>llvm</code></td><td><code>build/HOST/llvm</code></td></tr>
<tr><td><code>stage0</code> builds <code>codegen</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-codegen/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustdoc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-tools/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=0</code> stops here.</p>
<table><thead><tr><th>Stage 1 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage0-rustc</code> executable to <code>stage1</code></td><td><code>build/HOST/stage1/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage0-codegen</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td>copy (uplift) <code>stage0-sysroot</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td><code>stage1</code> builds <code>libstd</code></td><td><code>build/HOST/stage1-std/TARGET</code></td></tr>
<tr><td>copy <code>stage1-std</code> (HOST only)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>rustc</code></td><td><code>build/HOST/stage1-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage1-rustc</code> (except executable)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>codegen</code></td><td><code>build/HOST/stage1-codegen/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=1</code> stops here.</p>
<table><thead><tr><th>Stage 2 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage1-rustc</code> executable</td><td><code>build/HOST/stage2/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage1-sysroot</code></td><td><code>build/HOST/stage2/lib and build/HOST/stage2/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage2</code> builds <code>libstd</code> (except HOST?)</td><td><code>build/HOST/stage2-std/TARGET</code></td></tr>
<tr><td>copy <code>stage2-std</code> (not HOST targets)</td><td><code>build/HOST/stage2/lib/rustlib/TARGET</code></td></tr>
<tr><td><code>stage2</code> builds <code>rustdoc</code></td><td><code>build/HOST/stage2-tools/HOST</code></td></tr>
<tr><td>copy <code>rustdoc</code></td><td><code>build/HOST/stage2/bin</code></td></tr>
</tbody></table>
<p><code>--stage=2</code> stops here.</p>
<p>Note that the convention <code>x.py</code> uses is that:</p>
<ul>
<li>A &quot;stage N artifact&quot; is an artifact that is <em>produced</em> by the stage N compiler.</li>
<li>The &quot;stage (N+1) compiler&quot; is assembled from &quot;stage N artifacts&quot;.</li>
<li>A <code>--stage N</code> flag means build <em>with</em> stage N.</li>
</ul>
<p>In short, <em>stage 0 uses the stage0 compiler to create stage0 artifacts which
will later be uplifted to stage1</em>.</p>
<p>Every time any of the main artifacts (<code>std</code> and <code>rustc</code>) are compiled, two
steps are performed.
When <code>std</code> is compiled by a stage N compiler, that <code>std</code> will be linked to
programs built by the stage N compiler (including <code>rustc</code> built later
on). It will also be used by the stage (N+1) compiler to link against itself.
This is somewhat intuitive if one thinks of the stage (N+1) compiler as &quot;just&quot;
another program we are building with the stage N compiler. In some ways, <code>rustc</code>
(the binary, not the <code>rustbuild</code> step) could be thought of as one of the few
<code>no_core</code> binaries out there.</p>
<p>So &quot;stage0 std artifacts&quot; are in fact the output of the downloaded stage0
compiler, and are going to be used for anything built by the stage0 compiler:
e.g. <code>rustc</code> artifacts. When it announces that it is &quot;building stage1
std artifacts&quot; it has moved on to the next bootstrapping phase. This pattern
continues in latter stages.</p>
<p>Also note that building host <code>std</code> and target <code>std</code> are different based on the
stage (e.g. see in the table how stage2 only builds non-host <code>std</code> targets.
This is because during stage2, the host <code>std</code> is uplifted from the &quot;stage 1&quot;
<code>std</code> -- specifically, when &quot;Building stage 1 artifacts&quot; is announced, it is
later copied into stage2 as well (both the compiler's <code>libdir</code> and the
<code>sysroot</code>).</p>
<p>This <code>std</code> is pretty much necessary for any useful work with the compiler.
Specifically, it's used as the <code>std</code> for programs compiled by the newly compiled
compiler (so when you compile <code>fn main() { }</code> it is linked to the last <code>std</code>
compiled with <code>x.py build --stage 1 src/libstd</code>).</p>
<p>The <code>rustc</code> generated by the stage0 compiler is linked to the freshly-built
<code>libstd</code>, which means that for the most part only <code>std</code> needs to be cfg-gated,
so that <code>rustc</code> can use featured added to std immediately after their addition,
without need for them to get into the downloaded beta. The <code>libstd</code> built by the
<code>stage1/bin/rustc</code> compiler, also known as &quot;stage1 std artifacts&quot;, is not
necessarily ABI-compatible with that compiler.
That is, the <code>rustc</code> binary most likely could not use this <code>std</code> itself.
It is however ABI-compatible with any programs that the <code>stage1/bin/rustc</code>
binary builds (including itself), so in that sense they're paired.</p>
<p>This is also where <code>--keep-stage 1 src/libstd</code> comes into play. Since most
changes to the compiler don't actually change the ABI, once you've produced a
<code>libstd</code> in stage 1, you can probably just reuse it with a different compiler.
If the ABI hasn't changed, you're good to go, no need to spend the time
recompiling that <code>std</code>.
<code>--keep-stage</code> simply assumes the previous compile is fine and copies those
artifacts into the appropriate place, skipping the cargo invocation.</p>
<p>The reason we first build <code>std</code>, then <code>rustc</code>, is largely just
because we want to minimize <code>cfg(stage0)</code> in the code for <code>rustc</code>.
Currently <code>rustc</code> is always linked against a &quot;new&quot; <code>std</code> so it doesn't
ever need to be concerned with differences in std; it can assume that the std is
as fresh as possible.</p>
<p>The reason we need to build it twice is because of ABI compatibility.
The beta compiler has it's own ABI, and then the <code>stage1/bin/rustc</code> compiler
will produce programs/libraries with the new ABI.
We used to build three times, but because we assume that the ABI is constant
within a codebase, we presume that the libraries produced by the &quot;stage2&quot;
compiler (produced by the <code>stage1/bin/rustc</code> compiler) is ABI-compatible with
the <code>stage1/bin/rustc</code> compiler's produced libraries.
What this means is that we can skip that final compilation -- and simply use the
same libraries as the <code>stage2/bin/rustc</code> compiler uses itself for programs it
links against.</p>
<p>This <code>stage2/bin/rustc</code> compiler is shipped to end-users, along with the
<code>stage 1 {std,rustc}</code> artifacts.</p>
<p>If you want to learn more about <code>x.py</code>, read its README.md
<a href="https://github.com/rust-lang/rust/blob/master/src/bootstrap/README.md">here</a>.</p>
<h4><a class="header" href="#build-flags" id="build-flags">Build Flags</a></h4>
<p>There are other flags you can pass to the build command of <code>x.py</code> that can be
beneficial to cutting down compile times or fitting other things you might
need to change. They are:</p>
<pre><code class="language-txt">Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre>
<p>For hacking, often building the stage 1 compiler is enough, but for
final testing and release, the stage 2 compiler is used.</p>
<p><code>./x.py check</code> is really fast to build the rust compiler.
It is, in particular, very useful when you're doing some kind of
&quot;type-based refactoring&quot;, like renaming a method, or changing the
signature of some function.</p>
<p><a name=command></a></p>
<p>Once you've created a config.toml, you are now ready to run
<code>x.py</code>. There are a lot of options here, but let's start with what is
probably the best &quot;go to&quot; command for building a local rust:</p>
<pre><code class="language-bash">&gt; ./x.py build -i --stage 1 src/libstd
</code></pre>
<p>This may <em>look</em> like it only builds libstd, but that is not the case.
What this command does is the following:</p>
<ul>
<li>Build <code>libstd</code> using the stage0 compiler (using incremental)</li>
<li>Build <code>librustc</code> using the stage0 compiler (using incremental)
<ul>
<li>This produces the stage1 compiler</li>
</ul>
</li>
<li>Build libstd using the stage1 compiler (cannot use incremental)</li>
</ul>
<p>This final product (stage1 compiler + libs built using that compiler)
is what you need to build other rust programs (unless you use <code>#![no_std]</code> or
<code>#![no_core]</code>).</p>
<p>The command includes the <code>-i</code> switch which enables incremental compilation.
This will be used to speed up the first two steps of the process:
in particular, if you make a small change, we ought to be able to use your old
results to make producing the stage1 <strong>compiler</strong> faster.</p>
<p>Unfortunately, incremental cannot be used to speed up making the
stage1 libraries.  This is because incremental only works when you run
the <em>same compiler</em> twice in a row.  In this case, we are building a
<em>new stage1 compiler</em> every time. Therefore, the old incremental
results may not apply. <strong>As a result, you will probably find that
building the stage1 <code>libstd</code> is a bottleneck for you</strong> -- but fear not,
there is a (hacky) workaround.  See <a href="#workflow">the section on &quot;recommended
workflows&quot;</a> below.</p>
<p>Note that this whole command just gives you a subset of the full <code>rustc</code>
build. The <strong>full</strong> <code>rustc</code> build (what you get if you just say <code>./x.py build</code>) has quite a few more steps:</p>
<ul>
<li>Build <code>librustc</code> and <code>rustc</code> with the stage1 compiler.
<ul>
<li>The resulting compiler here is called the &quot;stage2&quot; compiler.</li>
</ul>
</li>
<li>Build libstd with stage2 compiler.</li>
<li>Build librustdoc and a bunch of other things with the stage2 compiler.</li>
</ul>
<p><a name=toolchain></a></p>
<h3><a class="header" href="#build-specific-components" id="build-specific-components">Build specific components</a></h3>
<p>Build only the libcore library</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore
</code></pre>
<p>Build the libcore and libproc_macro library only</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore src/libproc_macro
</code></pre>
<p>Build only libcore up to Stage 1</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore --stage 1
</code></pre>
<p>Sometimes you might just want to test if the part you’re working on can
compile. Using these commands you can test that it compiles before doing
a bigger build to make sure it works with the compiler. As shown before
you can also pass flags at the end such as --stage.</p>
<h3><a class="header" href="#creating-a-rustup-toolchain" id="creating-a-rustup-toolchain">Creating a rustup toolchain</a></h3>
<p>Once you have successfully built <code>rustc</code>, you will have created a bunch
of files in your <code>build</code> directory. In order to actually run the
resulting <code>rustc</code>, we recommend creating rustup toolchains. The first
one will run the stage1 compiler (which we built above). The second
will execute the stage2 compiler (which we did not build, but which
you will likely need to build at some point; for example, if you want
to run the entire test suite).</p>
<pre><code class="language-bash">&gt; rustup toolchain link stage1 build/&lt;host-triple&gt;/stage1
&gt; rustup toolchain link stage2 build/&lt;host-triple&gt;/stage2
</code></pre>
<p>The <code>&lt;host-triple&gt;</code> would typically be one of the following:</p>
<ul>
<li>Linux: <code>x86_64-unknown-linux-gnu</code></li>
<li>Mac: <code>x86_64-apple-darwin</code></li>
<li>Windows: <code>x86_64-pc-windows-msvc</code></li>
</ul>
<p>Now you can run the <code>rustc</code> you built with. If you run with <code>-vV</code>, you
should see a version number ending in <code>-dev</code>, indicating a build from
your local environment:</p>
<pre><code class="language-bash">&gt; rustc +stage1 -vV
rustc 1.25.0-dev
binary: rustc
commit-hash: unknown
commit-date: unknown
host: x86_64-unknown-linux-gnu
release: 1.25.0-dev
LLVM version: 4.0
</code></pre>
<p><a name=workflow></a></p>
<h3><a class="header" href="#suggested-workflows-for-faster-builds-of-the-compiler" id="suggested-workflows-for-faster-builds-of-the-compiler">Suggested workflows for faster builds of the compiler</a></h3>
<p>There are two workflows that are useful for faster builds of the compiler.</p>
<p><strong>Check, check, and check again.</strong> The first workflow, which is useful
when doing simple refactorings, is to run <code>./x.py check</code>
continuously. Here you are just checking that the compiler can
<strong>build</strong>, but often that is all you need (e.g., when renaming a
method). You can then run <code>./x.py build</code> when you actually need to
run tests.</p>
<p>In fact, it is sometimes useful to put off tests even when you are not
100% sure the code will work. You can then keep building up
refactoring commits and only run the tests at some later time. You can
then use <code>git bisect</code> to track down <strong>precisely</strong> which commit caused
the problem. A nice side-effect of this style is that you are left
with a fairly fine-grained set of commits at the end, all of which
build and pass tests. This often helps reviewing.</p>
<p><strong>Incremental builds with <code>--keep-stage</code>.</strong> Sometimes just checking
whether the compiler builds is not enough. A common example is that
you need to add a <code>debug!</code> statement to inspect the value of some
state or better understand the problem. In that case, you really need
a full build.  By leveraging incremental, though, you can often get
these builds to complete very fast (e.g., around 30 seconds). The only
catch is this requires a bit of fudging and may produce compilers that
don't work (but that is easily detected and fixed).</p>
<p>The sequence of commands you want is as follows:</p>
<ul>
<li>Initial build: <code>./x.py build -i --stage 1 src/libstd</code>
<ul>
<li>As <a href="#command">documented above</a>, this will build a functional
stage1 compiler as part of running all stage0 commands (which include
building a <code>libstd</code> compatible with the stage1 compiler) as well as the
first few steps of the &quot;stage 1 actions&quot; up to &quot;stage1 (sysroot stage1)
builds libstd&quot;.</li>
</ul>
</li>
<li>Subsequent builds: <code>./x.py build -i --stage 1 src/libstd --keep-stage 1</code>
<ul>
<li>Note that we added the <code>--keep-stage 1</code> flag here</li>
</ul>
</li>
</ul>
<p>As mentioned, the effect of <code>--keep-stage 1</code> is that we just <em>assume</em> that the
old standard library can be re-used. If you are editing the compiler, this
is almost always true: you haven't changed the standard library, after
all.  But sometimes, it's not true: for example, if you are editing
the &quot;metadata&quot; part of the compiler, which controls how the compiler
encodes types and other states into the <code>rlib</code> files, or if you are
editing things that wind up in the metadata (such as the definition of
the MIR).</p>
<p><strong>The TL;DR is that you might get weird behavior from a compile when
using <code>--keep-stage 1</code></strong> -- for example, strange
<a href="appendix/glossary.html">ICEs</a> or other panics. In that case, you
should simply remove the <code>--keep-stage 1</code> from the command and
rebuild.  That ought to fix the problem.</p>
<p>You can also use <code>--keep-stage 1</code> when running tests. Something like this:</p>
<ul>
<li>Initial test run: <code>./x.py test -i --stage 1 src/test/ui</code></li>
<li>Subsequent test run: <code>./x.py test -i --stage 1 src/test/ui --keep-stage 1</code></li>
</ul>
<h3><a class="header" href="#building-with-system-llvm" id="building-with-system-llvm">Building with system LLVM</a></h3>
<p>By default, LLVM is built from source, and that can take significant amount of time.
An alternative is to use LLVM already installed on your computer.</p>
<p>This is specified in the <code>target</code> section of <code>config.toml</code>:</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu]
llvm-config = &quot;/path/to/llvm/llvm-7.0.1/bin/llvm-config&quot;
</code></pre>
<h3><a class="header" href="#other-xpy-commands" id="other-xpy-commands">Other <code>x.py</code> commands</a></h3>
<p>Here are a few other useful <code>x.py</code> commands. We'll cover some of them in detail
in other sections:</p>
<ul>
<li>Building things:
<ul>
<li><code>./x.py clean</code> – clean up the build directory (<code>rm -rf build</code> works too,
but then you have to rebuild LLVM)</li>
<li><code>./x.py build --stage 1</code> – builds everything using the stage 1 compiler,
not just up to libstd</li>
<li><code>./x.py build</code> – builds the stage2 compiler</li>
</ul>
</li>
<li>Running tests (see the <a href="./tests/running.html">section on running tests</a> for
more details):
<ul>
<li><code>./x.py test --stage 1 src/libstd</code> – runs the <code>#[test]</code> tests from libstd</li>
<li><code>./x.py test --stage 1 src/test/ui</code> – runs the <code>ui</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics</code> - runs all the tests in
the <code>const-generics/</code> subdirectory of the <code>ui</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics/const-types.rs</code> - runs
the single test <code>const-types.rs</code> from the <code>ui</code> test suite</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#ctags" id="ctags">ctags</a></h3>
<p>One of the challenges with rustc is that the RLS can't handle it, since it's a
bootstrapping compiler. This makes code navigation difficult. One solution is to
use <code>ctags</code>.</p>
<p><code>ctags</code> has a long history and several variants. Exuberant Ctags seems to be
quite commonly distributed but it does not have out-of-box Rust support. Some
distributions seem to use <a href="https://github.com/universal-ctags/ctags">Universal Ctags</a>, which is a maintained fork
and does have built-in Rust support.</p>
<p>The following script can be used to set up Exuberant Ctags:
<a href="https://github.com/nikomatsakis/rust-etags">https://github.com/nikomatsakis/rust-etags</a>.</p>
<p><code>ctags</code> integrates into emacs and vim quite easily. The following can then be
used to build and generate tags:</p>
<pre><code class="language-console">$ rust-ctags src/lib* &amp;&amp; ./x.py build &lt;something&gt;
</code></pre>
<p>This allows you to do &quot;jump-to-def&quot; with whatever functions were around when
you last built, which is ridiculously useful.</p>
<h3><a class="header" href="#cleaning-out-build-directories" id="cleaning-out-build-directories">Cleaning out build directories</a></h3>
<p>Sometimes you need to start fresh, but this is normally not the case.
If you need to run this then rustbuild is most likely not acting right and
you should file a bug as to what is going wrong. If you do need to clean
everything up then you only need to run one command!</p>
<pre><code class="language-bash">&gt; ./x.py clean
</code></pre>
<h3><a class="header" href="#compiler-documentation" id="compiler-documentation">Compiler Documentation</a></h3>
<p>The documentation for the rust components are found at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/">rustc doc</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="compiler-team.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="build-install-distribution-artifacts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="compiler-team.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="build-install-distribution-artifacts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
